"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_object_1 = __importDefault(require("../lib/clone-object"));
var helpers_1 = require("../lib/helpers");
var matches_mimetype_1 = __importDefault(require("../lib/matches-mimetype"));
var openapi_to_json_schema_1 = __importStar(require("../lib/openapi-to-json-schema"));
var isJSON = matches_mimetype_1.default.json;
/**
 * Turn a header map from OpenAPI 3.0.3 (and some earlier versions too) into a schema.
 *
 * Note: This does not support OpenAPI 3.1.0's header format.
 *
 * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#headerObject}
 * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.3.md#headerObject}
 * @param response Response object to build a JSON Schema object for its headers for.
 */
function buildHeadersSchema(response, opts) {
    var headers = response.headers;
    var headersSchema = {
        type: 'object',
        properties: {},
    };
    Object.keys(headers).forEach(function (key) {
        if (headers[key] && headers[key].schema) {
            var header = headers[key];
            // TODO: Response headers are essentially parameters in OAS
            //    This means they can have content instead of schema.
            //    We should probably support that in the future
            headersSchema.properties[key] = (0, openapi_to_json_schema_1.default)(header.schema, {
                addEnumsToDescriptions: true,
                transformer: opts.transformer,
            });
            if (header.description) {
                headersSchema.properties[key].description = header.description;
            }
        }
    });
    var headersWrapper = {
        schema: headersSchema,
        type: 'object',
        label: 'Headers',
    };
    if (response.description && headersWrapper.schema) {
        headersWrapper.description = response.description;
    }
    return headersWrapper;
}
/**
 * Extract all the response schemas, matching the format of `get-parameters-as-json-schema`.
 *
 * Note: This expects a dereferenced schema.
 *
 * @param operation Operation to construct a response JSON Schema for.
 * @param api The OpenAPI definition that this operation originates.
 * @param statusCode The response status code to generate a schema for.
 */
function getResponseAsJSONSchema(operation, api, statusCode, opts) {
    var response = operation.getResponseByStatusCode(statusCode);
    var jsonSchema = [];
    if (!response) {
        return null;
    }
    var hasCircularRefs = false;
    var hasDiscriminatorMappingRefs = false;
    function refLogger(ref, type) {
        if (type === 'ref') {
            hasCircularRefs = true;
        }
        else {
            hasDiscriminatorMappingRefs = true;
        }
    }
    /**
     * @param content An array of `MediaTypeObject`'s to retrieve a preferred schema out of. We
     *    prefer JSON media types.
     */
    function getPreferredSchema(content) {
        if (!content) {
            return null;
        }
        var contentTypes = Object.keys(content);
        if (!contentTypes.length) {
            return null;
        }
        // eslint-disable-next-line no-plusplus
        for (var i = 0; i < contentTypes.length; i++) {
            if (isJSON(contentTypes[i])) {
                return (0, openapi_to_json_schema_1.default)((0, clone_object_1.default)(content[contentTypes[i]].schema), {
                    addEnumsToDescriptions: true,
                    refLogger: refLogger,
                    transformer: opts.transformer,
                });
            }
        }
        // We always want to prefer the JSON-compatible content types over everything else but if we
        // haven't found one we should default to the first available.
        var contentType = contentTypes.shift();
        return (0, openapi_to_json_schema_1.default)((0, clone_object_1.default)(content[contentType].schema), {
            addEnumsToDescriptions: true,
            refLogger: refLogger,
            transformer: opts.transformer,
        });
    }
    var foundSchema = getPreferredSchema(response.content);
    if (foundSchema) {
        var schema = (0, clone_object_1.default)(foundSchema);
        var schemaWrapper = {
            // If there's no `type` then the root schema is a circular `$ref` that we likely won't be
            // able to render so instead of generating a JSON Schema with an `undefined` type we should
            // default to `string` so there's at least *something* the end-user can interact with.
            type: foundSchema.type || 'string',
            schema: (0, helpers_1.isPrimitive)(schema)
                ? schema
                : __assign(__assign({}, schema), { $schema: (0, openapi_to_json_schema_1.getSchemaVersionString)(schema, api) }),
            label: 'Response body',
        };
        if (response.description && schemaWrapper.schema) {
            schemaWrapper.description = response.description;
        }
        /**
         * Since this library assumes that the schema has already been dereferenced, adding every
         * component here that **isn't** circular adds a ton of bloat so it'd be cool if `components`
         * was just the remaining `$ref` pointers that are still being referenced.
         *
         * @todo
         */
        if (api.components && schemaWrapper.schema) {
            // We should only include components if we've got circular refs or we have discriminator
            // mapping refs (we want to include them).
            if (hasCircularRefs || (hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs)) {
                schemaWrapper.schema.components = api.components;
            }
        }
        jsonSchema.push(schemaWrapper);
    }
    // 3.0.3 and earlier headers. TODO: New format for 3.1.0
    if (response.headers) {
        jsonSchema.push(buildHeadersSchema(response, opts));
    }
    return jsonSchema.length ? jsonSchema : null;
}
exports.default = getResponseAsJSONSchema;
