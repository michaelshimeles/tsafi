"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var data_urls_1 = require("@readme/data-urls");
var readable_stream_1 = require("readable-stream");
if (!globalThis.Blob) {
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies
        globalThis.Blob = require('formdata-node').Blob;
    }
    catch (e) {
        throw new Error('Since you do not have the Blob API available in this environment you must install the optional `formdata-node` dependency.');
    }
}
if (!globalThis.File) {
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies
        globalThis.File = require('formdata-node').File;
    }
    catch (e) {
        throw new Error('Since you do not have the File API available in this environment you must install the optional `formdata-node` dependency.');
    }
}
if (!globalThis.FormData) {
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires, import/no-extraneous-dependencies
        globalThis.FormData = require('formdata-node').FormData;
    }
    catch (e) {
        throw new Error('Since you do not have the FormData API available in this environment you must install the optional `formdata-node` dependency.');
    }
}
function isBrowser() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}
function isBuffer(value) {
    return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);
}
function isFile(value) {
    if (value instanceof File) {
        /**
         * The `Blob` polyfill on Node comes back as being an instanceof `File`. Because passing a Blob
         * into a File will end up with a corrupted file we want to prevent this.
         *
         * This object identity crisis does not happen in the browser.
         */
        return value.constructor.name === 'File';
    }
    return false;
}
/**
 * @license MIT
 * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFunction.ts}
 */
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * We're using this library in here instead of loading it from `form-data-encoder` because that
 * uses lookbehind regex in its main encoder that Safari doesn't support so it throws a fatal page
 * exception.
 *
 * @license MIT
 * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFormData.ts}
 */
function isFormData(value) {
    return (value &&
        isFunction(value.constructor) &&
        value[Symbol.toStringTag] === 'FormData' &&
        isFunction(value.append) &&
        isFunction(value.getAll) &&
        isFunction(value.entries) &&
        isFunction(value[Symbol.iterator]));
}
function getFileFromSuppliedFiles(filename, files) {
    if (filename in files) {
        return files[filename];
    }
    else if (decodeURIComponent(filename) in files) {
        return files[decodeURIComponent(filename)];
    }
    return false;
}
function fetchHAR(har, opts) {
    var _a;
    if (opts === void 0) { opts = {}; }
    if (!har)
        throw new Error('Missing HAR definition');
    if (!har.log || !har.log.entries || !har.log.entries.length)
        throw new Error('Missing log.entries array');
    var request = har.log.entries[0].request;
    var url = request.url;
    var querystring = '';
    var shouldSetDuplex = false;
    var options = __assign(__assign({}, (opts.init ? opts.init : {})), { method: request.method });
    if (!options.headers) {
        options.headers = new Headers();
    }
    else if (typeof options.headers === 'object' && !(options.headers instanceof Headers) && options.headers !== null) {
        options.headers = new Headers(options.headers);
    }
    var headers = options.headers;
    if ('headers' in request && request.headers.length) {
        // eslint-disable-next-line consistent-return
        request.headers.forEach(function (header) {
            try {
                return headers.append(header.name, header.value);
            }
            catch (err) {
                /**
                 * `Headers.append()` will throw errors if the header name is not a legal HTTP header name,
                 * like `X-API-KEY (Header)`. If that happens instead of tossing the error back out, we
                 * should silently just ignore
                 * it.
                 */
            }
        });
    }
    if ('cookies' in request && request.cookies.length) {
        /**
         * As the browser fetch API can't set custom cookies for requests, they instead need to be
         * defined on the document and passed into the request via `credentials: include`. Since this
         * is a browser-specific quirk, that should only
         * happen in browsers!
         */
        if (isBrowser()) {
            request.cookies.forEach(function (cookie) {
                document.cookie = "".concat(encodeURIComponent(cookie.name), "=").concat(encodeURIComponent(cookie.value));
            });
            options.credentials = 'include';
        }
        else {
            headers.append('cookie', request.cookies
                .map(function (cookie) { return "".concat(encodeURIComponent(cookie.name), "=").concat(encodeURIComponent(cookie.value)); })
                .join('; '));
        }
    }
    if ('postData' in request) {
        if ('params' in request.postData) {
            if (!('mimeType' in request.postData)) {
                // @ts-expect-error HAR spec requires that `mimeType` is always present but it might not be.
                request.postData.mimeType = 'application/octet-stream';
            }
            switch (request.postData.mimeType) {
                case 'application/x-www-form-urlencoded':
                    /**
                     * Since the content we're handling here is to be encoded as
                     * `application/x-www-form-urlencoded`, this should override any other `Content-Type`
                     * headers that are present in the HAR. This is how Postman handles this case when
                     * building code snippets!
                     *
                     * @see {@link https://github.com/github/fetch/issues/263#issuecomment-209530977}
                     */
                    headers.set('Content-Type', request.postData.mimeType);
                    var encodedParams_1 = new URLSearchParams();
                    request.postData.params.forEach(function (param) { return encodedParams_1.set(param.name, param.value); });
                    options.body = encodedParams_1.toString();
                    break;
                case 'multipart/alternative':
                case 'multipart/form-data':
                case 'multipart/mixed':
                case 'multipart/related':
                    /**
                     * If there's a `Content-Type` header set we need to remove it. We're doing this because
                     * when we pass the form data object into `fetch` that'll set a proper `Content-Type`
                     * header for this request that also includes the boundary used on the content.
                     *
                     * If we don't do this, then consumers won't be able to parse out the payload because
                     * they won't know what the boundary to split on it.
                     */
                    if (headers.has('Content-Type')) {
                        headers["delete"]('Content-Type');
                    }
                    var form_1 = new FormData();
                    if (!isFormData(form_1)) {
                        /**
                         * The `form-data` NPM module returns one of two things: a native `FormData` API or its
                         * own polyfill. Unfortunately this polyfill does not support the full API of the native
                         * FormData object so when you load `form-data` within a browser environment you'll
                         * have two major differences in API:
                         *
                         *  - The `.append()` API in `form-data` requires that the third argument is an object
                         *    containing various, undocumented, options. In the browser, `.append()`'s third
                         *    argument should only be present when the second is a `Blob` or `USVString`, and
                         *    when it is present, it should be a filename string.
                         *  - `form-data` does not expose an `.entries()` API, so the only way to retrieve data
                         *    out of it for construction of boundary-separated payload content is to use its
                         *    `.pipe()` API. Since the browser doesn't have this API, you'll be unable to
                         * retrieve data out of it.
                         *
                         * Now since the native `FormData` API is iterable, and has the `.entries()` iterator,
                         * we can easily detect if we have a native copy of the FormData API. It's for all of
                         * these reasons that we're opting to hard crash here because supporting this
                         * non-compliant API is more trouble than its worth.
                         *
                         * @see {@link https://github.com/form-data/form-data/issues/124}
                         */
                        throw new Error("We've detected you're using a non-spec compliant FormData library. We recommend polyfilling FormData with https://npm.im/formdata-node");
                    }
                    request.postData.params.forEach(function (param) {
                        if ('fileName' in param) {
                            if (opts.files) {
                                var fileContents = getFileFromSuppliedFiles(param.fileName, opts.files);
                                if (fileContents) {
                                    // If the file we've got available to us is a Buffer then we need to convert it so
                                    // that the FormData API can use it.
                                    if (isBuffer(fileContents)) {
                                        form_1.append(param.name, new File([fileContents], param.fileName, {
                                            type: param.contentType || null
                                        }), param.fileName);
                                        return;
                                    }
                                    else if (isFile(fileContents)) {
                                        form_1.append(param.name, fileContents, param.fileName);
                                        return;
                                    }
                                    throw new TypeError('An unknown object has been supplied into the `files` config for use. We only support instances of the File API and Node Buffer objects.');
                                }
                            }
                            if ('value' in param) {
                                var paramBlob = void 0;
                                var parsed = (0, data_urls_1.parse)(param.value);
                                if (parsed) {
                                    // If we were able to parse out this data URL we don't need to transform its data
                                    // into a buffer for `Blob` because that supports data URLs already.
                                    paramBlob = new Blob([param.value], { type: parsed.contentType || param.contentType || null });
                                }
                                else {
                                    paramBlob = new Blob([param.value], { type: param.contentType || null });
                                }
                                form_1.append(param.name, paramBlob, param.fileName);
                                return;
                            }
                            throw new Error("The supplied HAR has a postData parameter with `fileName`, but neither `value` content within the HAR or any file buffers were supplied with the `files` option. Since this library doesn't have access to the filesystem, it can't fetch that file.");
                        }
                        form_1.append(param.name, param.value);
                    });
                    /**
                     * If a the `fetch` polyfill that's being used here doesn't have spec-compliant handling
                     * for the `FormData` API (like `node-fetch@2`), then you should pass in a handler (like
                     * the `form-data-encoder` library) to transform its contents into something that can be
                     * used with the `Request` object.
                     *
                     * @see {@link https://www.npmjs.com/package/formdata-node}
                     */
                    if (opts.multipartEncoder) {
                        // eslint-disable-next-line new-cap
                        var encoder_1 = new opts.multipartEncoder(form_1);
                        Object.keys(encoder_1.headers).forEach(function (header) {
                            headers.set(header, encoder_1.headers[header]);
                        });
                        // @ts-expect-error "Property 'from' does not exist on type 'typeof Readable'." but it does!
                        options.body = readable_stream_1.Readable.from(encoder_1);
                        shouldSetDuplex = true;
                    }
                    else {
                        options.body = form_1;
                    }
                    break;
                default:
                    var formBody_1 = {};
                    request.postData.params.map(function (param) {
                        try {
                            formBody_1[param.name] = JSON.parse(param.value);
                        }
                        catch (e) {
                            formBody_1[param.name] = param.value;
                        }
                        return true;
                    });
                    options.body = JSON.stringify(formBody_1);
            }
        }
        else if ((_a = request.postData.text) === null || _a === void 0 ? void 0 : _a.length) {
            // If we've got `files` map content present, and this post data content contains a valid data
            // URL then we can substitute the payload with that file instead of the using data URL.
            if (opts.files) {
                var parsed = (0, data_urls_1.parse)(request.postData.text);
                if (parsed) {
                    if ((parsed === null || parsed === void 0 ? void 0 : parsed.name) && parsed.name in opts.files) {
                        var fileContents = getFileFromSuppliedFiles(parsed.name, opts.files);
                        if (fileContents) {
                            if (isBuffer(fileContents)) {
                                options.body = fileContents;
                            }
                            else if (isFile(fileContents)) {
                                // `Readable.from` isn't available in browsers but the browser `Request` object can
                                // handle `File` objects just fine without us having to mold it into shape.
                                if (isBrowser()) {
                                    options.body = fileContents;
                                }
                                else {
                                    // @ts-expect-error "Property 'from' does not exist on type 'typeof Readable'." but it does!
                                    options.body = readable_stream_1.Readable.from(fileContents.stream());
                                    shouldSetDuplex = true;
                                    // Supplying a polyfilled `File` stream into `Request.body` doesn't automatically
                                    // add `Content-Length`.
                                    if (!headers.has('content-length')) {
                                        headers.set('content-length', String(fileContents.size));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (typeof options.body === 'undefined') {
                options.body = request.postData.text;
            }
        }
        /**
         * The fetch spec, which Node 18+ strictly abides by, now requires that `duplex` be sent with
         * requests that have payloads.
         *
         * As `RequestInit#duplex` isn't supported by any browsers, or even mentioned on MDN, we aren't
         * sending it in browser environments. This work is purely to support Node 18+ and `undici`
         * environments.
         *
         * @see {@link https://github.com/nodejs/node/issues/46221}
         * @see {@link https://github.com/whatwg/fetch/pull/1457}
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Request/Request}
         */
        if (shouldSetDuplex && !isBrowser()) {
            options.duplex = 'half';
        }
    }
    // We automaticaly assume that the HAR that we have already has query parameters encoded within
    // it so we do **not** use the `URLSearchParams` API here for composing the query string.
    var requestURL = url;
    if ('queryString' in request && request.queryString.length) {
        var urlObj = new URL(requestURL);
        var queryParams_1 = Array.from(urlObj.searchParams).map(function (_a) {
            var k = _a[0], v = _a[1];
            return "".concat(k, "=").concat(v);
        });
        request.queryString.forEach(function (q) {
            queryParams_1.push("".concat(q.name, "=").concat(q.value));
        });
        querystring = queryParams_1.join('&');
        // Because anchor hashes before query strings will prevent query strings from being delivered
        // we need to pop them off and re-add them after.
        if (urlObj.hash) {
            var urlWithoutHashes = requestURL.replace(urlObj.hash, '');
            requestURL = "".concat(urlWithoutHashes.split('?')[0]).concat(querystring ? "?".concat(querystring) : '');
            requestURL += urlObj.hash;
        }
        else {
            requestURL = "".concat(requestURL.split('?')[0]).concat(querystring ? "?".concat(querystring) : '');
        }
    }
    if (opts.userAgent) {
        headers.append('User-Agent', opts.userAgent);
    }
    options.headers = headers;
    return fetch(requestURL, options);
}
exports["default"] = fetchHAR;
